---
title: "中国製ドローンのハッキング"
date: "2025-11-2"
author: "Waka"
categories: ["技術", "ドローン","ハッキング","セキュリティ"]
tags: ["ドローン", "ハッキング", "セキュリティ", "リーバスエンジニアリング"]
excerpt: "中国製ドローンの2.4GHz帯通信を解析し、セキュリティ上の脆弱性を検証しました。"
---

# Aliexpressで購入した激安ドローンをハッキングしてみた

## はじめに

皆さんは、Aliexpressを使ったことがありますか？私は、Aliexpressで掘り出し物を見つけるのが大好きです。ある日、いつものようにAliexpressを探索していると、2.4GHz帯で動作する激安ドローンを発見しました。その価格はなんと約3000円。この価格でドローンが手に入るなんて、買わない理由がありません。

しかし、ただ買って飛ばすだけでは面白くありません。せっかくなら技術的に深掘りして、通信プロトコルを解析してみようと考えました。ということで、このドローンのハッキングに挑戦することにしました。

## 購入したドローンについて

購入したドローンは、Aliexpressで多くの販売業者が取り扱っているモデルです。購入場所によって商品名に表記ゆれがありますが、ここでは最も多く使われている「GT3」という表記を用います。

![Aliexpressで販売されているドローンのモデル](/images/Drone/ali.png)

このドローン、非常に興味深い特徴があります。誰が設計して、誰がどのように販売しているのか、まったくわかりません。さらに面白いことに、ドローン本体に印字されている商品名は、それぞれの販売業者に適合した商品名になっています。つまり、このような怪しいドローンに印字までして、Aliexpressの販売業者に卸す業者が存在するということです。

好奇心から分解してみたところ、中のチップは全てレーザーで印字が消されていました。そのため、チップのデータシートも見つけられず、リバースエンジニアリングを行うには少し大変な状況でした。

## 直面した問題

ハッキングを始めるにあたって、まず以下の2つの大きな障害に直面しました。

1. **データシートが存在しない問題**: チップにアクセスしようにも、印字が消されているためピン配置がわかりません
2. **通信方式が不明**: どういう方式で通信を行っているのかがわかりません

データシート問題については、どうしようもないので今回は諦めることにしました。代わりに、通信解析に焦点を当てることにしました。

当初、私はこのドローンがnRF24L01のような独自の2.4GHz通信方式（いわゆるRF24方式）で通信していると仮定していました。RF24方式とは、2.4GHz帯域を使用しながらも、802.11（Wi-Fi）などの標準プロトコルではなく、古来のラジコンのような独自の通信方式で通信する方法です。結果的には、この仮定が大きな遠回りとなりました。

## ESP32とnRF24L01を用いたツールの開発

最初のアプローチとして、nRF24L01モジュールを使用することにしました。nRF24L01は、Arduinoなどのマイコンで使える2.4GHz帯の無線通信モジュールで、その辺で簡単に入手できます。このモジュールを使えば、周辺の2.4GHz帯の通信強度を測定したり、通信内容をキャプチャしたりできます。

詳細な使い方については、[cifertech氏のページ](https://cifertech.net/how-to-make-2-4-ghz-band-scanner-with-nrf24l01/)で解説されています。

![使用したツール](/images/Drone/nRF24.jpg)

次に、2.4GHz帯の中で具体的にどの周波数で通信しているのかを知りたかったので、ESP32を使った専用のスペクトラムアナライザーソフトウェアを設計しました。

![観測したシグナル](/images/Drone/signal.png)

ドローンを実際に操縦しながら、どの周波数の信号強度が変化するかを観測しました。その結果、2427MHz、2462MHz、2437MHzあたりで強い信号が多く受信されました。

この時点で、私は重大な見落としをしていました。

- 2427MHzは802.11（Wi-Fi）のチャンネル4（正確には2427MHz）
- 2462MHzはチャンネル11（正確には2462MHz）
- 2437MHzはチャンネル6（正確には2437MHz）

つまり、これらはすべてWi-Fiの標準チャンネルだったのです。このデータを見た時点でWi-Fiだと気づくべきでしたが、私はRF24方式だと信じ込んでいたため、ずっと独自プロトコルとして通信キャプチャを行おうとしていました。今思えば、非常に愚かなことをしました。

## nRF24L01での通信キャプチャの試み

次に、ドローンのON時とOFF時で大きく変化が見られた2427MHzに目星をつけて、nRF24L01で空中を飛んでいる電波を直接取得しようと試みました。

実際にデータを取得することはできたのですが、その内容は000000だったり111111だったりと、意味をなさないデータばかりでした。nRF24L01は802.11プロトコルには対応していないため、当然と言えば当然の結果でした。

もうお手上げかと思われた時、重要なことを思い出しました。

## 専用アプリの存在を思い出す

この怪しい中国製ドローンには、もちろん怪しい専用アプリが存在します。そのアプリでは、ドローンが発するWi-Fiアクセスポイントにスマートフォンを接続して、アプリから操縦する方式でした。

ここでやっと、ドローンがWi-Fi（802.11プロトコル）という標準規格の上に構築されたネットワーク機器であることに気が付いたのです。これは大きな進展でした。

しかし、新たな問題がありました。私は、Wi-Fiパケットをキャプチャできる、いわゆるモニターモード（promiscuousモード）対応のUSBアダプターを持っていなかったのです。

## USBドングルの購入

Wi-Fiパケットをキャプチャするためには、モニターモードをサポートするWi-Fiアダプターが必要です。HackRFのような高性能なSDR（Software Defined Radio）が欲しかったのですが、高価で手が届きません（笑）。

そこで、GeminiとChatGPTに相談し、推奨されたUSBドングルを購入しました。

![購入したUSBドングル](/images/Drone/USB.png)

早速購入してPCに接続し、Wiresharkを使って2427MHz（チャンネル4）のパケットをキャプチャしようと試みました。しかし、うまくいきませんでした。

理由は明確でした。**ノイズが多すぎる**のです。私の家には、Wi-Fiを発する機器が多すぎました。ルーター、スマートフォン、IoTデバイスなど、無数のデバイスが2.4GHz帯で通信しています。目的のドローンからのパケットが、これらのノイズに埋もれてしまっているのです。

さらに、飛んでいるデータを見ても、内容が全然わかりません。このプロジェクトは失敗に終わったかと思いました。

## ESP32で中継作戦

次に考えたのが、ESP32を中継機器として立てて、コントローラーとドローンの間のパケットを見るという作戦でした。

結果として、この方法でパケットをキャプチャすることは一応できました。しかし、いくつかの問題がありました。

- ポーリングレートをESP32の限界まで上げても、すべてのパケットを捕捉できない
- 途中で出力が途切れることがある
- ESP32が非常に高温になる（爆熱状態）
- かなり長いコードでEPS32同士をシリアル通信にしなければならい(同じAP名なので)

私の手元には、1500円で購入した貴重なESP32-WROOM-32Dが2つしかありません。これが壊れるのは困るので、この方法は断念しました。

## 専用アプリの解析という突破口

ここで、重要なひらめきがありました。**専用アプリを解析すればいいのでは？**

早速、APKファイルを入手して、Jadx（Androidアプリケーションのデコンパイルツール）を使って解析を開始しました。

すると、驚くべきことに、たくさんの送信パケット情報とポート番号の情報が出てきたのです！アプリ内には、ドローンとの通信に使用されるプロトコルの詳細が、ほぼ平文で記載されていました。

これは大きな成果でした。アプリのソースコードを読むことで、以下のような情報を得ることができました。

- 通信に使用されるUDPポート番号
- コマンドフォーマット
- パケット構造
- 制御コマンドの種類

## 解析した情報のまとめ

アプリの解析により、このドローンの通信プロトコルの詳細が明らかになりました。以下、判明した制御方法とパケット情報をまとめます。

### 通信方式の概要

このドローンの制御は、PCやESP32などのコントローラーが**ドローンのWi-Fiアクセスポイント（AP）に接続**し、**UDPパケットを一方的に送信し続ける**ことで行われます。

- **接続方式**: TCPのような接続確立（ハンドシェイク）は行われません
- **通信プロトコル**: UDP（ポート `8800`）を使用
- **送信方式**: 「ファイア・アンド・フォーゲット（撃ちっぱなし）」方式
- **フェイルセーフ機構**: 制御ループは、ユーザーが何も操作していない待機中でも停止しません。常に**秒間数十回**（例: 80Hz）のレートで「中立パケット」を送信し続け、ドローンはこのパケットが途絶えると通信が切れたと判断します

### スティック操作の計算方法

ユーザーのキー入力を、ドローンに送信するスティック値（範囲: 40〜220、中央値: 128）に変換する計算方法です。これは `WifiUavRcModel` クラスが担当し、非常に滑らかな操作感を実現しています。

#### 1. 加速（キーを押した時）

キーが押されると、スティック値は中心(128)から最大/最小値に向かって**徐々に加速**します。
```
加速度 = accel_rate × Δt × (1 + expo_factor × dist_ratio)
```

- `expo_factor`（指数係数）により、**スティックが中心に近いほど加速度が上がり、敏感に反応**します

#### 2. 減速（キーを離した時）

キーが離されると、スティック値は**徐々に中心(128)に戻ります**。
```
減速度 = decel_rate × Δt × (1 + 0.5 × dist_ratio)
```

- **スティックが中心から遠いほど減速度が上がり、素早く中心に戻ります**。これにより、操作を止めた時に機体の動きがピタッと止まる感覚になります

#### 3. 即時ブースト（ピッチとロールのみ）

左右や前後に操作方向を切り替えた瞬間、ごくわずかな値が即座に加算されます。これにより、キー入力に対する機体の反応がより「即時的」に感じられます。

#### 4. コントロール・プロファイル

`"normal"`, `"precise"`, `"aggressive"` といった飛行モードがあり、上記の計算で使われる `accel_rate`（加速度）や `expo_factor`（感度）などのパラメータを切り替えることができます。

### パケット構造の詳細

解析の過程で2種類のパケット形式が判明しました。最終的に使用されているのは、より複雑な**最終パケット形式**です。

#### A. 旧式/単純なパケット（全20バイト）

`DroneController` のテストコードに見られた古い形式です。

- **ヘッダー**: `0x66`
- **フッター**: `0x99`
- **構造**:
  - `[0]`: `0x66` (ヘッダー)
  - `[1]`: 速度
  - `[2-5]`: ロール, ピッチ, スロットル, ヨー (中央値128)
  - `[6]`: コマンド1 (離陸 `0x01`, 着陸 `0x02`, 停止 `0x04`)
  - `[7]`: コマンド2 (基本値 `0x0a` + 録画 `0x04`)
  - `[8-17]`: ゼロ埋め
  - `[18]`: **チェックサム** (バイト2〜17のXOR)
  - `[19]`: `0x99` (フッター)

#### B. 最終パケット形式（全123バイト）

`WifiUavRcProtocolAdapter` で使用される、リバースエンジニアリングに基づいた**正規のパケット**です。大量の固定バイト列と、3つのローリングカウンターが特徴です。

パケットは以下の6つのブロックで構成されています。

**ブロック1: ヘッダー（12バイト）**
```
0xef 0x02 0x7c 0x00 0x02 0x02 0x00 0x01 0x02 0x00 0x00 0x00
```
静的なマジックナンバーです。

**ブロック2: カウンター1（8バイト）**
- **`_ctr1`（2バイト）**: 16ビットのカウンター。送信ごとに +1 されます（リトルエンディアン）
- `_COUNTER1_SUFFIX`（6バイト）: 固定値 `0x00 0x00 0x14 0x00 0x66 0x14`

**ブロック3: 制御データ（16バイト）**
- **`controls`（6バイト）**: ここが操作の核となる部分です
  - `[0]`: **ロール**（範囲: 40〜220、待機時: 128）
  - `[1]`: **ピッチ**（範囲: 40〜220、待機時: 128）
  - `[2]`: **スロットル**（範囲: 40〜220、待機時: 128）
  - `[3]`: **ヨー**（範囲: 40〜220、待機時: 128）
  - `[4]`: **コマンド**（詳細は後述）
  - `[5]`: **ヘッドレスモード**（OFF: `0x02`, ON: `0x03`）
- `_CONTROL_SUFFIX`（10バイト）: `0x00` で埋められます

**ブロック4: チェックサム（51バイト）**
- **`checksum`（1バイト）**: **ブロック3の `controls`（6バイト）のみをXORした**単純なチェックサムです
- `_CHECKSUM_SUFFIX`（50バイト）: 静的なマジックナンバーです

**ブロック5: カウンター2（20バイト）**
- **`_ctr2`（2バイト）**: 2つ目の16ビットカウンター。送信ごとに +1 されます
- `_COUNTER2_SUFFIX`（18バイト）: 固定値

**ブロック6: カウンター3（16バイト）**
- **`_ctr3`（2バイト）**: 3つ目の16ビットカウンター。送信ごとに +1 されます
- `_COUNTER3_SUFFIX`（14バイト）: 固定値

### コマンド一覧

ブロック3の `controls[4]`（コマンドバイト）に設定される値です。これらは「ワンショット」で動作し、一度送信されるとフラグがクリアされます。

| 値 | コマンド | 説明 |
|:---|:---|:---|
| `0x00` | **コマンド無し** | 待機中（ニュートラル）の状態。常にこの値で送信される |
| `0x01` | **離陸** | ドローンに離陸を指示する |
| `0x02` | **着陸 / 緊急停止** | ドローンに着陸、またはモーターの緊急停止を指示する |
| `0x04` | **ジャイロ・キャリブレーション** | ドローンのジャイロセンサーを校正する |


![解析した結果](/images/Drone/diagram_1.png)


# 実際にESP32で送信して、動作するか確認する

## パケット送信テストの成功

アプリの解析により判明したパケット構造を基に、いよいよ実機テストを行う段階に入りました。ESP32にUDP送信プログラムを実装し、解析したパケットフォーマット通りにデータを組み立てて送信してみました。

最初は半信半疑でしたが、テストパケットを送信すると、なんと**ドローンが実際に反応しました**！最初に試したのはジャイロ校正コマンド（`0x04`）だけでしたが、ドローンのLEDが点滅し、明らかに校正処理が実行されていることが確認できました。

ここまでの道のりは約3か月。最初にドローンを購入してから、nRF24L01での試行錯誤、WiFi解析の失敗、アプリの解析、そしてパケット構造の解明と、長い道のりでした。この時点で秋も深まり、かなり寒くなってきていたので、ようやく動作確認が取れて心から安心しました。

## 専用コントローラーの設計

動作確認が取れたことで、次のステップとして、ドローン専用のハードウェアコントローラーを設計することにしました。せっかく通信プロトコルが解明できたのですから、市販のコントローラーに頼らず、自分だけのカスタムコントローラーを作りたいという欲求が湧いてきました。

![3DモデルPCB](/images/Drone/PCB.png)

何となく、かっこいい名前がついていた方がテンションが上がるので、このプロジェクトに**「MINE VESPER」**という名前を付けました。中二病？いいえ、こういうネーミングはモチベーション維持に重要なんです。プロジェクトに愛着が湧きますし、何より作業していて楽しいです。

### 設計コンセプト

このコントローラーの設計にあたって、以下のコンセプトを掲げました。

1. **コンパクトで持ち運びやすい**: ポケットに入るサイズ感
2. **直感的な操作性**: アナログスティックによる滑らかな制御
3. **視認性の高いディスプレイ**: リアルタイムで制御状態を確認できる
4. **拡張性**: 将来的に機能追加が容易な設計
5. **低コスト**: できるだけ一般的な部品を使用して製作コストを抑える

### PCB設計の詳細

PCBの設計には、KiCadを使用しました。基板は表裏両面実装で、表面にはユーザーインターフェース部品（スティック、ディスプレイ、ボタン）を配置し、裏面にはESP32モジュールを配置する設計としました。

当初は、ESP32-S3をSMD（表面実装）で直接実装する案も検討しました。atomic14氏が公開している[basic-esp32s3-dev-board](https://github.com/atomic14/basic-esp32s3-dev-board)の設計を参考にすれば、よりコンパクトで洗練されたデザインにできるはずでした。

しかし、SMD部品の実装には専用のヒートガンやリフロー設備が必要です。残念ながら私の作業環境にはそのような設備がなく、ハンダゴテだけでの実装は品質面でリスクが高いと判断しました。そのため、最終的には**モジュール式**のESP32-WROOM-32Dを採用することにしました。モジュール式であれば、通常のハンダ付けで確実に実装でき、また万が一の故障時にも交換が容易です。

### 使用部品リスト

設計はできるだけシンプルに、かつ必要十分な機能を持たせることを心がけました。使用した部品は以下の通りです。

#### メインコンポーネント

- **ESP32-WROOM-32D**: マイコンモジュール
  - Wi-Fi通信機能内蔵
  - デュアルコア、240MHz動作
  - 豊富なGPIOピン
  - 価格: 約1,500円

#### 入力デバイス

- **ALPS電気 RKJXV1224005**: 2軸アナログジョイスティック
  - 5ピン構成（X軸、Y軸、プッシュスイッチ、VCC、GND）
  - 10kΩの可変抵抗内蔵
  - 滑らかな操作感で、ドローンの精密な制御に最適
  - 価格: 約800円

- **6mm タクトスイッチ × 5個**: 離陸、着陸、校正などの機能ボタン用
  - 標準的な4ピンタイプ
  - プッシュ時の確実なクリック感
  - 価格: 1個あたり約10円

#### 出力デバイス

- **SSD1306 OLEDディスプレイ**: 0.96インチ 128×64ピクセル
  - I2C通信で簡単に接続可能
  - 高コントラストで視認性が良い
  - 制御パラメータや接続状態をリアルタイム表示
  - 価格: 約500円

#### その他部品

- **プルアップ/プルダウン抵抗**: 10kΩ × 4個
  - ボタン入力の安定化用
  - ノイズ対策


### 総製作コスト

部品代の合計は約1000円程度と、非常にリーズナブルな価格で実現できました。基板の製造費用（JLCPCBなどの格安基板製造サービスを利用）を含めても、2000円以内で製作可能です。

市販のドローンコントローラーが数千円から数万円することを考えると、自作ならではのコストパフォーマンスの良さと、何より自分で設計した達成感が得られます。

### ソフトウェアの実装

ハードウェアの設計と並行して、ESP32用のファームウェアも開発しました。主な機能は以下の通りです。

- **Wi-Fi接続管理**: ドローンのAPへの自動接続
- **UDP送信ループ**: 80Hzでの高頻度パケット送信
- **ジョイスティック入力処理**: ADC読み取りとスティック値への変換
- **ボタン入力処理**: コマンド送信のトリガー
- **ディスプレイ制御**: リアルタイム情報の表示更新

特に、解析で判明した「常に中立パケットを送信し続ける」というフェイルセーフ機構を忠実に再現することで、安定した通信を実現しました。

### 次のステップ

基板の設計が完了したら、次は実際に基板を発注して組み立て、実機でのテストを行います。もし問題があれば設計を見直し、最終的には完全に自作のドローンコントローラーとして完成させる予定です。

今回はJLCPCBを選択しました。最近?になってカラー基板の値段がすべて同じになったので、パープルを選択してみました。黒と緑は大量に生産するためか、正味4日程度で届くんですが、今回は7日ほどかかりました。

![本当はもっと薄い紫色だと信じたい](/images/Drone/PCB2.png)

また追記します。